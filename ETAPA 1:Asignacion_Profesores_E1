import pandas as pd
from pulp import LpProblem, LpVariable, lpSum, LpMaximize, LpStatus, PULP_CBC_CMD
import sys
from typing import Dict, List, Tuple

class AsignacionProfesores:
    """
    Clase para resolver el problema de asignaci√≥n de profesores a clases
    usando programaci√≥n lineal entera.
    """

    def __init__(self):
        self.df_clases = None
        self.df_preferencias = None
        self.profesores = []
        self.clases_idx = []
        self.planta_profes = []
        self.contrato_profes = []
        self.modulos = []
        self.horarios = []
        self.clase_info = {}
        self.preferencia_combinada = {}
        self.max_clases = {}

        # Nombres de columnas configurables
        self.COLUMNA_MODULO = 'M√ìDULO'
        self.COLUMNA_HORARIO = 'HORARIO'
        self.COLUMNA_PARALELO = 'PARALELO'

    def cargar_datos(self, ruta_clases: str = "/content/clases.xlsx",
                     ruta_preferencias: str = "/content/preferencias_profesores.xlsx"):
        """
        Carga los datos desde archivos Excel y valida la estructura.

        Args:
            ruta_clases: Ruta del archivo de clases
            ruta_preferencias: Ruta del archivo de preferencias
        """
        print("--- ETAPA 1: CARGA DE DATOS ---")
        try:
            print("Cargando datos desde archivos Excel...")
            self.df_clases = pd.read_excel(ruta_clases)
            self.df_preferencias = pd.read_excel(ruta_preferencias, index_col="PROFESOR")
            print("‚úì Datos cargados correctamente.")

            self._validar_estructura_datos()

        except FileNotFoundError as e:
            print(f"‚ùå Error: Archivo no encontrado - {e}")
            sys.exit()
        except Exception as e:
            print(f"‚ùå Error al cargar archivos: {e}")
            sys.exit()

    def _validar_estructura_datos(self):
        """Valida que las columnas requeridas existan en los DataFrames."""
        print("Validando estructura de datos...")

        # Validar columnas en df_clases
        columnas_requeridas_clases = [self.COLUMNA_MODULO, self.COLUMNA_HORARIO]
        for col in columnas_requeridas_clases:
            if col not in self.df_clases.columns:
                raise ValueError(f"Columna '{col}' no encontrada en clases.xlsx")

        # Crear columna PARALELO si no existe
        if self.COLUMNA_PARALELO not in self.df_clases.columns:
            print(f"‚ö†Ô∏è Columna '{self.COLUMNA_PARALELO}' no encontrada. Usando 'N/A'.")
            self.df_clases[self.COLUMNA_PARALELO] = 'N/A'

        # Convertir horarios a string
        if not pd.api.types.is_string_dtype(self.df_clases[self.COLUMNA_HORARIO]):
            print(f"‚ö†Ô∏è Convirtiendo columna '{self.COLUMNA_HORARIO}' a texto...")
            self.df_clases[self.COLUMNA_HORARIO] = self.df_clases[self.COLUMNA_HORARIO].astype(str)

        print("‚úì Estructura de datos validada.")

    def preparar_conjuntos_parametros(self):
        """
        Identifica y prepara todos los conjuntos y par√°metros del modelo.
        """
        print("\n--- ETAPA 2: PREPARACI√ìN DE CONJUNTOS Y PAR√ÅMETROS ---")

        # Identificar profesores y tipos
        self.profesores = self.df_preferencias.index.tolist()
        self.clases_idx = self.df_clases.index.tolist()
        self.planta_profes = [p for p in self.profesores if p.startswith("Planta")]
        self.contrato_profes = [p for p in self.profesores if not p.startswith("Planta")]

        print(f"üìä Total profesores: {len(self.profesores)} (Planta: {len(self.planta_profes)}, Contrato: {len(self.contrato_profes)})")
        print(f"üìö Total clases: {len(self.clases_idx)}")

        # Identificar m√≥dulos y horarios
        self._identificar_modulos_horarios()

        # Preparar informaci√≥n de clases
        self.clase_info = self.df_clases.set_index(self.df_clases.index).to_dict('index')

        # Calcular preferencias
        self._calcular_preferencias()

        print("‚úì Conjuntos y par√°metros preparados.")

    def _identificar_modulos_horarios(self):
        """Identifica las columnas de m√≥dulos y horarios en el DataFrame de preferencias."""
        try:
            all_columns = self.df_preferencias.columns.tolist()
            col_clases = all_columns[0]  # Primera columna: max clases

            # Encontrar √≠ndices de referencia
            idx_col_clases = all_columns.index(col_clases)
            idx_last_module = all_columns.index('A4')

            # Extraer m√≥dulos y horarios
            self.modulos = all_columns[idx_col_clases + 1 : idx_last_module + 1]
            self.horarios = all_columns[idx_last_module + 1 :]

            print(f"üìã M√≥dulos identificados: {self.modulos}")
            print(f"üïê Horarios identificados: {self.horarios}")

            if not self.modulos or not self.horarios:
                raise ValueError("No se pudieron identificar m√≥dulos o horarios")

        except (ValueError, IndexError) as e:
            print(f"‚ùå Error identificando columnas: {e}")
            sys.exit()

    def _calcular_preferencias(self):
        """Calcula las preferencias combinadas (m√≥dulo √ó horario) para cada profesor-clase."""
        print("Calculando preferencias combinadas...")

        # Extraer preferencias por m√≥dulo y horario
        pref_mod = self.df_preferencias[self.modulos].stack().to_dict()
        pref_hor = self.df_preferencias[self.horarios].stack().to_dict()

        # Obtener m√°ximo de clases por profesor
        col_clases = self.df_preferencias.columns[0]
        self.max_clases = self.df_preferencias[col_clases].to_dict()

        # Calcular preferencias combinadas
        coincidencias = 0
        for profesor in self.profesores:
            for clase_idx in self.clases_idx:
                info_clase = self.clase_info[clase_idx]
                modulo_clase = info_clase[self.COLUMNA_MODULO]
                horario_clase = info_clase[self.COLUMNA_HORARIO].strip()

                pref_modulo = int(pref_mod.get((profesor, modulo_clase), 0))
                pref_horario = int(pref_hor.get((profesor, horario_clase), 0))

                # Preferencia combinada: 1 si ambas son 1, 0 en caso contrario
                pref_combinada = pref_modulo * pref_horario
                self.preferencia_combinada[profesor, clase_idx] = pref_combinada

                if pref_combinada == 1:
                    coincidencias += 1

        print(f"‚úì {coincidencias} coincidencias perfectas (preferencia = 1) encontradas.")

    def construir_modelo(self):
        """
        Construye el modelo de programaci√≥n lineal con todas las restricciones.
        """
        print("\n--- ETAPA 3: CONSTRUCCI√ìN DEL MODELO ---")

        # Crear problema de maximizaci√≥n
        self.prob = LpProblem("Asignacion_Profesores_E1", LpMaximize)

        # Variables de decisi√≥n: x[profesor, clase] ‚àà {0, 1}
        self.x = LpVariable.dicts(
            "Asignacion",
            [(p, c) for p in self.profesores for c in self.clases_idx],
            cat='Binary'
        )

        # Funci√≥n objetivo: Maximizar suma de preferencias
        self.prob += lpSum(
            self.preferencia_combinada[p, c] * self.x[p, c]
            for p in self.profesores for c in self.clases_idx
        ), "Maximizar_Preferencias_Totales"

        print("‚úì Funci√≥n objetivo definida.")

        # A√±adir restricciones
        self._a√±adir_restricciones()

        print("‚úì Modelo construido completamente.")

    def _a√±adir_restricciones(self):
        """A√±ade todas las restricciones al modelo."""
        print("A√±adiendo restricciones...")

        # R1: Cobertura total - Cada clase debe ser asignada a exactamente un profesor
        for c in self.clases_idx:
            self.prob += lpSum(self.x[p, c] for p in self.profesores) == 1, f"Cobertura_Clase_{c}"

        # R2: Carga obligatoria de planta - Profesores de planta deben tener exactamente 3 clases
        for p in self.planta_profes:
            self.prob += lpSum(self.x[p, c] for c in self.clases_idx) == 3, f"Carga_Planta_{p}"

        # R3: Carga m√°xima de contrato - Profesores de contrato no pueden exceder su m√°ximo
        for p in self.contrato_profes:
            self.prob += lpSum(self.x[p, c] for c in self.clases_idx) <= self.max_clases[p], f"Carga_Max_Contrato_{p}"

        # R4: Conflicto de horarios - Un profesor no puede estar en dos clases al mismo tiempo
        for profesor in self.profesores:
            for horario in self.horarios:
                clases_en_horario = [
                    c for c in self.clases_idx
                    if self.clase_info[c][self.COLUMNA_HORARIO].strip() == horario
                ]
                if clases_en_horario:
                    nombre_horario_seguro = "".join(filter(str.isalnum, horario))
                    self.prob += lpSum(self.x[profesor, c] for c in clases_en_horario) <= 1, \
                                f"Sin_Conflicto_{profesor}_{nombre_horario_seguro}"

        # R5: M√≥dulos permitidos - Solo asignar profesores a m√≥dulos que pueden ense√±ar
        pref_mod = self.df_preferencias[self.modulos].stack().to_dict()
        for profesor in self.profesores:
            for clase in self.clases_idx:
                modulo_clase = self.clase_info[clase][self.COLUMNA_MODULO]
                puede_ensenar = pref_mod.get((profesor, modulo_clase), 0)
                self.prob += self.x[profesor, clase] <= puede_ensenar, \
                            f"Modulo_Permitido_{profesor}_{clase}"

        print("‚úì Todas las restricciones a√±adidas.")

    def resolver_modelo(self):
        """
        Resuelve el modelo de optimizaci√≥n.
        """
        print("\n--- ETAPA 4: RESOLUCI√ìN ---")
        print("Resolviendo modelo de optimizaci√≥n...")

        solver = PULP_CBC_CMD(msg=0)  # Solver silencioso
        self.prob.solve(solver)

        print(f"‚úì Modelo resuelto. Estado: {LpStatus[self.prob.status]}")
        return LpStatus[self.prob.status]

    def generar_resultados(self, exportar_excel: bool = True):
        """
        Genera y presenta los resultados de la asignaci√≥n.

        Args:
            exportar_excel: Si exportar resultados a Excel
        """
        print("\n--- ETAPA 5: RESULTADOS ---")

        estado = LpStatus[self.prob.status]
        print(f"üìä Estado de la soluci√≥n: {estado}")

        # Mostrar valor objetivo
        if self.prob.objective is not None:
            valor_objetivo = self.prob.objective.value()
            print(f"üéØ Valor √≥ptimo (suma de preferencias): {valor_objetivo or 'N/A'}")

        if estado == 'Optimal':
            self._procesar_solucion_optima(exportar_excel)
        elif estado == 'Infeasible':
            self._manejar_infactibilidad()
        else:
            print(f"‚ùå No se encontr√≥ soluci√≥n √≥ptima. Estado: {estado}")

    def _procesar_solucion_optima(self, exportar_excel: bool):
        """Procesa y presenta la soluci√≥n √≥ptima encontrada."""
        print("\nüéâ ¬°SOLUCI√ìN √ìPTIMA ENCONTRADA!")

        # Extraer asignaciones
        asignaciones = []
        carga_profesores = {p: 0 for p in self.profesores}

        for (profesor, clase), variable in self.x.items():
            if variable.varValue > 0.9:  # Asignado
                info_clase = self.clase_info[clase]
                preferencia = self.preferencia_combinada.get((profesor, clase), 0)

                asignaciones.append({
                    "Profesor": profesor,
                    "Clase_ID": clase,
                    "Modulo": info_clase[self.COLUMNA_MODULO],
                    "Horario": info_clase[self.COLUMNA_HORARIO].strip(),
                    "Paralelo": info_clase.get(self.COLUMNA_PARALELO, 'N/A'),
                    "Preferencia_Cumplida": preferencia
                })
                carga_profesores[profesor] += 1

        # Crear DataFrame de resultados
        df_resultados = pd.DataFrame(asignaciones)
        df_resultados.sort_values(by=["Profesor", "Horario"], inplace=True)

        # Mostrar asignaciones
        print("\nüìã ASIGNACIONES DETALLADAS:")
        with pd.option_context('display.max_rows', None, 'display.max_columns', None, 'display.width', 1200):
            print(df_resultados)

        # Exportar a Excel si se solicita
        if exportar_excel:
            self._exportar_excel(df_resultados)

        # Mostrar resumen de carga
        self._mostrar_resumen_carga(carga_profesores)

        # Verificar profesores sin asignaci√≥n
        self._verificar_profesores_sin_asignacion(carga_profesores)

    def _exportar_excel(self, df_resultados: pd.DataFrame):
        """Exporta los resultados a un archivo Excel."""
        try:
            nombre_archivo = "asignacion_etapa1_resultado.xlsx"
            df_resultados.to_excel(nombre_archivo, index=False)
            print(f"\nüíæ ¬°Resultados exportados a '{nombre_archivo}'!")
        except Exception as e:
            print(f"\n‚ùå Error al exportar: {e}")

    def _mostrar_resumen_carga(self, carga_profesores: Dict[str, int]):
        """Muestra el resumen de carga por profesor."""
        print("\nüìä RESUMEN DE CARGA POR PROFESOR:")
        print("-" * 60)

        for profesor in self.profesores:
            tipo = "Planta" if profesor in self.planta_profes else "Contrato"
            maximo = self.max_clases[profesor]
            asignadas = carga_profesores[profesor]

            # Indicador visual de cumplimiento
            if tipo == "Planta":
                indicador = "‚úì" if asignadas == 3 else "‚ùå"
            else:
                indicador = "‚úì" if asignadas > 0 else "‚ö†Ô∏è"

            print(f"{indicador} {profesor:12} ({tipo:8}): {asignadas:2d} clases asignadas (M√°x: {maximo})")

    def _verificar_profesores_sin_asignacion(self, carga_profesores: Dict[str, int]):
        """Verifica y reporta profesores de contrato sin asignaciones."""
        sin_asignacion = [p for p in self.contrato_profes if carga_profesores[p] == 0]

        print("\nüîç VERIFICACI√ìN DE COBERTURA:")
        if not sin_asignacion:
            print("‚úÖ ¬°EXCELENTE! Todos los profesores de contrato tienen al menos una clase.")
        else:
            print("‚ö†Ô∏è  ADVERTENCIA: Profesores de contrato sin clases asignadas:")
            for profesor in sin_asignacion:
                print(f"   - {profesor}")
            print("   üí° Posibles causas: incompatibilidad m√≥dulo/horario o alta competencia.")

    def _manejar_infactibilidad(self):
        """Maneja el caso de problema infactible."""
        print("\n‚ùå PROBLEMA INFACTIBLE")
        print("No existe soluci√≥n que cumpla todas las restricciones.")
        print("\nüí° Posibles causas:")
        print("   - Insuficientes profesores para cubrir todas las clases")
        print("   - Restricciones de horario muy estrictas")
        print("   - Incompatibilidad entre m√≥dulos y profesores disponibles")
        print("   - Carga obligatoria de planta demasiado alta")

    def ejecutar_proceso_completo(self, ruta_clases: str = "/content/clases.xlsx",
                                  ruta_preferencias: str = "/content/preferencias_profesores.xlsx"):
        """
        Ejecuta todo el proceso de asignaci√≥n de principio a fin.

        Args:
            ruta_clases: Ruta del archivo de clases
            ruta_preferencias: Ruta del archivo de preferencias

        Returns:
            str: Estado final de la soluci√≥n
        """
        print("=" * 80)
        print("üéì SISTEMA DE ASIGNACI√ìN DE PROFESORES - ETAPA 1")
        print("=" * 80)

        try:
            # Ejecutar todas las etapas
            self.cargar_datos(ruta_clases, ruta_preferencias)
            self.preparar_conjuntos_parametros()
            self.construir_modelo()
            estado = self.resolver_modelo()
            self.generar_resultados()

            print("\n" + "=" * 80)
            print("‚úÖ PROCESO COMPLETADO EXITOSAMENTE")
            print("=" * 80)

            return estado

        except Exception as e:
            print(f"\n‚ùå ERROR CR√çTICO: {e}")
            print("=" * 80)
            return "Error"


# ===== FUNCI√ìN PRINCIPAL =====
def main():
    """Funci√≥n principal para ejecutar el sistema de asignaci√≥n."""
    asignador = AsignacionProfesores()
    estado_final = asignador.ejecutar_proceso_completo()
    return estado_final


# ===== EJECUCI√ìN =====
if __name__ == "__main__":
    main()
