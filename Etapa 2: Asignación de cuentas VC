import pandas as pd
import pulp
from pulp import LpProblem, LpVariable, lpSum, LpMinimize, LpStatus, PULP_CBC_CMD
import sys
from collections import defaultdict
import itertools
import time
import warnings

# Configuración para evitar warnings innecesarios
warnings.filterwarnings('ignore')

def cargar_datos_etapa1(archivo_path="/content/asignacion_etapa1_resultado.xlsx"):
    """
    Carga los datos de la salida de la Etapa 1.

    Args:
        archivo_path (str): Ruta del archivo Excel de la Etapa 1

    Returns:
        pd.DataFrame: DataFrame con los datos cargados
    """
    try:
        print("📂 Cargando datos desde la salida de la Etapa 1...")
        df_etapa1 = pd.read_excel(archivo_path)
        print(f"✅ Datos cargados correctamente. Registros encontrados: {len(df_etapa1)}")
        return df_etapa1
    except FileNotFoundError:
        print("❌ Error: No se encontró el archivo 'asignacion_etapa1_output.xlsx'.")
        print("   Por favor, ejecuta la Etapa 1 primero.")
        sys.exit()
    except Exception as e:
        print(f"❌ Error al cargar el archivo Excel de la Etapa 1: {e}")
        sys.exit()

def procesar_horarios(df_etapa1):
    """
    Procesa los horarios de los profesores y crea estructuras de datos necesarias.

    Args:
        df_etapa1 (pd.DataFrame): DataFrame con datos de la Etapa 1

    Returns:
        tuple: (horarios_por_profesor, conjunto_horarios_unicos)
    """
    horarios_por_profesor = defaultdict(set)
    all_unique_horarios = set()

    for index, row in df_etapa1.iterrows():
        # Validar que la columna Horario existe y no es nula
        if 'Horario' not in row or pd.isna(row['Horario']):
            print(f"⚠️  Advertencia: Fila {index} no tiene Horario o es nulo. Omitiendo.")
            continue

        horario_limpio = str(row['Horario']).strip()
        profesor = row['Profesor']

        horarios_por_profesor[profesor].add(horario_limpio)
        all_unique_horarios.add(horario_limpio)

    return horarios_por_profesor, list(all_unique_horarios)

def calcular_pares_contiguos(profesores_activos, horarios_por_profesor):
    """
    Calcula pares de profesores con horarios contiguos.

    Args:
        profesores_activos (list): Lista de profesores activos
        horarios_por_profesor (dict): Diccionario de horarios por profesor

    Returns:
        set: Conjunto de pares contiguos
    """
    # Orden canónico de horarios para determinar contigüidad
    orden_horarios = ['08H00-10H00', '15H00-17H00', '17H00-19H00', '19H00-21H00']
    horario_a_indice = {h: i for i, h in enumerate(orden_horarios)}

    def check_contiguity(h1, h2):
        """Verifica si dos horarios son contiguos"""
        idx1 = horario_a_indice.get(h1)
        idx2 = horario_a_indice.get(h2)
        if idx1 is None or idx2 is None:
            return False  # Horario no estándar
        return abs(idx1 - idx2) == 1

    pares_contiguos = set()

    for p1, p2 in itertools.combinations(profesores_activos, 2):
        horarios_p1 = horarios_por_profesor.get(p1, set())
        horarios_p2 = horarios_por_profesor.get(p2, set())

        # Verificar si existe algún par de horarios contiguos
        tiene_contiguo = any(
            check_contiguity(h1, h2)
            for h1 in horarios_p1
            for h2 in horarios_p2
        )

        if tiene_contiguo:
            pares_contiguos.add(tuple(sorted((p1, p2))))

    return pares_contiguos

def calcular_pares_solapamiento(profesores_activos, horarios_por_profesor):
    """
    Calcula pares de profesores con solapamiento de horarios.

    Args:
        profesores_activos (list): Lista de profesores activos
        horarios_por_profesor (dict): Diccionario de horarios por profesor

    Returns:
        tuple: (pares_solapamiento_por_horario, total_pares_solapamiento)
    """
    # Crear mapeo de horario -> lista de profesores
    profesores_por_horario = defaultdict(list)
    for profesor in profesores_activos:
        for horario in horarios_por_profesor.get(profesor, set()):
            profesores_por_horario[horario].append(profesor)

    # Encontrar pares que comparten horarios
    pares_solapamiento_por_horario = defaultdict(set)

    for horario, lista_profesores in profesores_por_horario.items():
        if len(lista_profesores) >= 2:
            for p1, p2 in itertools.combinations(lista_profesores, 2):
                pares_solapamiento_por_horario[horario].add(tuple(sorted((p1, p2))))

    total_pares = sum(len(pares) for pares in pares_solapamiento_por_horario.values())

    return pares_solapamiento_por_horario, total_pares

def crear_modelo_optimizacion(profesores_activos, cuentas_disponibles,
                            pares_contiguos, pares_solapamiento_por_horario,
                            num_clases_por_profesor, config):
    """
    Crea el modelo de optimización para asignación de cuentas VC.

    Args:
        profesores_activos (list): Lista de profesores activos
        cuentas_disponibles (list): Lista de cuentas disponibles
        pares_contiguos (set): Pares de profesores con horarios contiguos
        pares_solapamiento_por_horario (dict): Pares con solapamiento por horario
        num_clases_por_profesor (dict): Número de clases por profesor
        config (dict): Configuración del modelo

    Returns:
        tuple: (problema, variables_y, variables_u, variables_v)
    """
    print("🔧 Definiendo el modelo de optimización...")

    # Crear problema de minimización
    prob = LpProblem("Asignacion_Cuentas_VC_Optimizada", LpMinimize)

    # Variables de decisión
    # y[p,a] = 1 si profesor p es asignado a cuenta a
    y = LpVariable.dicts("AsignacionCuenta",
                        [(p, a) for p in profesores_activos for a in cuentas_disponibles],
                        cat='Binary')

    # u[a] = 1 si cuenta adicional a es utilizada
    u = LpVariable.dicts("UsoCuentaAdicional", config['cuentas_adicionales'], cat='Binary')

    # v[a] = 1 si cuenta base a es utilizada
    v = LpVariable.dicts("UsoCuentaBase", config['cuentas_base'], cat='Binary')

    # Función objetivo: minimizar costo ponderado de cuentas
    prob += (config['peso_adicional'] * lpSum(u[a] for a in config['cuentas_adicionales']) +
             config['peso_base'] * lpSum(v[a] for a in config['cuentas_base'])), \
             "Minimizar_Costo_Ponderado_Cuentas"

    # RESTRICCIONES
    print("📋 Añadiendo restricciones al modelo...")

    # R1: Cada profesor debe ser asignado a exactamente una cuenta
    for p in profesores_activos:
        prob += lpSum(y[p, a] for a in cuentas_disponibles) == 1, \
                f"AsignacionUnica_{p}"

    # R2: Máximo 3 profesores por cuenta
    for a in cuentas_disponibles:
        prob += lpSum(y[p, a] for p in profesores_activos) <= 3, \
                f"LimiteCompartir_{a}"

    # R3: Exclusividad para profesores con 3 clases
    profesores_3_clases = [p for p in profesores_activos
                          if num_clases_por_profesor.get(p, 0) == 3]

    if profesores_3_clases:
        print(f"   👤 Aplicando exclusividad para {len(profesores_3_clases)} profesores con 3 clases")
        for p in profesores_3_clases:
            for a in cuentas_disponibles:
                otros_profesores = [p_prime for p_prime in profesores_activos if p_prime != p]
                prob += lpSum(y[p_prime, a] for p_prime in otros_profesores) <= 3 * (1 - y[p, a]), \
                        f"Exclusividad3Clases_{p}_{a}"

    # R4: Prohibir compartir cuenta entre profesores con horarios contiguos
    if pares_contiguos:
        print(f"   ⏰ Aplicando restricción de no contigüidad para {len(pares_contiguos)} pares")
        for p1, p2 in pares_contiguos:
            if p1 in profesores_activos and p2 in profesores_activos:
                for a in cuentas_disponibles:
                    prob += y[p1, a] + y[p2, a] <= 1, \
                            f"NoContiguo_{p1}_{p2}_{a}"

    # R5: Prohibir conflictos de horario en la misma cuenta
    total_pares_solapamiento = sum(len(pares) for pares in pares_solapamiento_por_horario.values())
    if total_pares_solapamiento > 0:
        print(f"   🔄 Aplicando restricción de no solapamiento para {total_pares_solapamiento} pares")
        for horario, pares_en_horario in pares_solapamiento_por_horario.items():
            horario_seguro = "".join(filter(str.isalnum, horario))
            for p1, p2 in pares_en_horario:
                if p1 in profesores_activos and p2 in profesores_activos:
                    for a in cuentas_disponibles:
                        prob += y[p1, a] + y[p2, a] <= 1, \
                                f"NoSolapamiento_{p1}_{p2}_{horario_seguro}_{a}"

    # R6: Activación de cuentas adicionales
    for a in config['cuentas_adicionales']:
        for p in profesores_activos:
            prob += y[p, a] <= u[a], f"ActivarUsoAdicional_{p}_{a}"

    # R7: Activación de cuentas base
    for a in config['cuentas_base']:
        for p in profesores_activos:
            prob += y[p, a] <= v[a], f"ActivarUsoBase_{p}_{a}"

    print("✅ Modelo definido correctamente")
    return prob, y, u, v

def resolver_problema(prob, tiempo_limite=600):
    """
    Resuelve el problema de optimización.

    Args:
        prob: Problema de PuLP
        tiempo_limite (int): Tiempo límite en segundos

    Returns:
        int: Estado de la solución
    """
    print(f"🚀 Resolviendo el problema... (Tiempo límite: {tiempo_limite} segundos)")

    solver = PULP_CBC_CMD(timeLimit=tiempo_limite, gapRel=0.01, msg=True)
    prob.solve(solver)

    return prob.status

def procesar_resultados(prob, y, u, v, profesores_activos, cuentas_disponibles,
                       config, num_clases_por_profesor, horarios_por_profesor):
    """
    Procesa y presenta los resultados de la optimización.

    Args:
        prob: Problema resuelto
        y, u, v: Variables del modelo
        profesores_activos (list): Lista de profesores
        cuentas_disponibles (list): Lista de cuentas
        config (dict): Configuración
        num_clases_por_profesor (dict): Número de clases por profesor
        horarios_por_profesor (dict): Horarios por profesor

    Returns:
        pd.DataFrame: DataFrame con los resultados
    """
    status_text = LpStatus[prob.status]
    print(f"\n📊 Estado de la solución: {status_text}")

    if pulp.LpStatus[prob.status] != "Optimal":
        if pulp.LpStatus[prob.status] == "Infeasible":
            print("❌ El problema es INFACTIBLE. Revisar las restricciones.")
        else:
            print(f"⚠️ Estado del problema: {pulp.LpStatus[prob.status]}")
        return None

    # Calcular estadísticas de uso de cuentas
    try:
        num_adicionales_usadas = int(sum(u[a].varValue or 0 for a in config['cuentas_adicionales']))
        num_base_usadas = int(sum(v[a].varValue or 0 for a in config['cuentas_base']))
        num_total_cuentas = num_base_usadas + num_adicionales_usadas

        print(f"\n📈 RESUMEN DE CUENTAS:")
        print(f"   • Cuentas base utilizadas: {num_base_usadas}/{config['num_base']}")
        print(f"   • Cuentas adicionales necesarias: {num_adicionales_usadas}")
        print(f"   • TOTAL de cuentas utilizadas: {num_total_cuentas}")

        cuentas_base_libres = config['num_base'] - num_base_usadas
        if cuentas_base_libres > 0:
            print(f"   • Cuentas base disponibles sin usar: {cuentas_base_libres}")

    except (TypeError, AttributeError):
        print("⚠️  No se pudieron calcular las estadísticas de cuentas")

    # Procesar asignaciones individuales
    resultados = []
    cuentas_usadas = defaultdict(list)

    for p in profesores_activos:
        cuenta_asignada = None

        for a in cuentas_disponibles:
            if hasattr(y[p, a], 'varValue') and y[p, a].varValue and y[p, a].varValue > 0.9:
                cuenta_asignada = a
                cuentas_usadas[a].append(p)
                break

        if cuenta_asignada is None:
            print(f"⚠️  No se encontró asignación para el profesor: {p}")
            cuenta_asignada = "ERROR"

        resultados.append({
            "Profesor": p,
            "NumClases": num_clases_por_profesor.get(p, 0),
            "CuentaVC_Asignada": cuenta_asignada,
            "Horarios": ", ".join(sorted(horarios_por_profesor.get(p, set())))
        })

    # Crear DataFrame de resultados
    df_resultados = pd.DataFrame(resultados)

    # Ordenar resultados
    try:
        if "ERROR" not in df_resultados["CuentaVC_Asignada"].values:
            df_resultados = df_resultados.astype({"CuentaVC_Asignada": int})
            df_resultados.sort_values(by=["CuentaVC_Asignada", "Profesor"], inplace=True)
    except (ValueError, TypeError):
        df_resultados.sort_values(by=["Profesor"], inplace=True)

    # Mostrar resultados
    print(f"\n👥 ASIGNACIÓN DE CUENTAS POR PROFESOR:")
    print(df_resultados.to_string(index=False))

    print(f"\n🏢 RESUMEN DE USO POR CUENTA:")
    for cuenta in sorted(cuentas_usadas.keys()):
        profesores_en_cuenta = cuentas_usadas[cuenta]
        tipo_cuenta = "Base" if cuenta <= config['num_base'] else "Adicional"
        print(f"   Cuenta {cuenta} ({tipo_cuenta}): {len(profesores_en_cuenta)} profesor(es)")
        print(f"      → {', '.join(sorted(profesores_en_cuenta))}")

    return df_resultados

def exportar_resultados(df_resultados, archivo_salida="asignación_VC_E2.xlsx"):
    """
    Exporta los resultados a un archivo Excel.

    Args:
        df_resultados (pd.DataFrame): DataFrame con los resultados
        archivo_salida (str): Nombre del archivo de salida
    """
    try:
        # Exportar solo las columnas necesarias para la Etapa 3
        df_export = df_resultados[['Profesor', 'CuentaVC_Asignada']].copy()
        df_export.to_excel(archivo_salida, index=False)
        print(f"\n💾 Resultados exportados exitosamente a '{archivo_salida}'")
    except Exception as e:
        print(f"❌ Error al exportar resultados: {e}")

def main():
    """Función principal que ejecuta todo el proceso de la Etapa 2."""
    print("🎯 === INICIANDO ETAPA 2: ASIGNACIÓN DE CUENTAS VC ===")
    start_time = time.time()

    # 1. Cargar datos de la Etapa 1
    df_etapa1 = cargar_datos_etapa1()

    # 2. Procesar datos básicos
    profesores_activos = df_etapa1['Profesor'].unique().tolist()
    if not profesores_activos:
        print("❌ No hay profesores activos. Terminando proceso.")
        sys.exit()

    num_clases_por_profesor = df_etapa1['Profesor'].value_counts().to_dict()
    horarios_por_profesor, horarios_unicos = procesar_horarios(df_etapa1)

    # 3. Configuración del modelo
    config = {
        'num_base': 20,  # Número de cuentas base disponibles
        'num_max': len(profesores_activos),  # Cota superior teórica
        'peso_adicional': 1000,  # Peso para cuentas adicionales
        'peso_base': 1  # Peso para cuentas base
    }

    config['cuentas_base'] = list(range(1, config['num_base'] + 1))
    config['cuentas_adicionales'] = list(range(config['num_base'] + 1, config['num_max'] + 1)) \
                                   if config['num_max'] > config['num_base'] else []
    cuentas_disponibles = config['cuentas_base'] + config['cuentas_adicionales']

    # 4. Calcular restricciones
    print("\n🔍 Analizando restricciones...")
    pares_contiguos = calcular_pares_contiguos(profesores_activos, horarios_por_profesor)
    pares_solapamiento, total_solapamiento = calcular_pares_solapamiento(profesores_activos, horarios_por_profesor)

    print(f"   📊 Estadísticas del problema:")
    print(f"      • Profesores activos: {len(profesores_activos)}")
    print(f"      • Pares con horarios contiguos: {len(pares_contiguos)}")
    print(f"      • Pares con solapamiento de horario: {total_solapamiento}")
    print(f"      • Cuentas disponibles: {len(cuentas_disponibles)} (Base: {len(config['cuentas_base'])}, Adicionales: {len(config['cuentas_adicionales'])})")

    # 5. Crear y resolver modelo
    prob, y, u, v = crear_modelo_optimizacion(
        profesores_activos, cuentas_disponibles, pares_contiguos,
        pares_solapamiento, num_clases_por_profesor, config
    )

    status = resolver_problema(prob, tiempo_limite=600)

    # 6. Procesar y mostrar resultados
    df_resultados = procesar_resultados(
        prob, y, u, v, profesores_activos, cuentas_disponibles,
        config, num_clases_por_profesor, horarios_por_profesor
    )

    # 7. Exportar resultados si son válidos
    if df_resultados is not None and "ERROR" not in df_resultados["CuentaVC_Asignada"].values:
        exportar_resultados(df_resultados)

    # 8. Tiempo total de ejecución
    end_time = time.time()
    print(f"\n⏱️  Tiempo total de ejecución: {end_time - start_time:.2f} segundos")
    print("🏁 === FIN DE LA ETAPA 2 ===")

# Ejecutar el programa principal
if __name__ == "__main__":
    main()
